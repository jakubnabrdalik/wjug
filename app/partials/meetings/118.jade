div
    .section(page='1')
        .centered
            .container
                .row
                    .span12
                        h4 118 spotkanie WJUGa
                        h2 Java Memory Model
                        h3 Michał Warecki
                        p Termin: 06.18.2013 godz. 18:00
                        p Lokalizacja: MIMUW,
                        p Plakat: 
                            a(href="https://docs.google.com/file/d/0B8d787eZJXI_YVNWMml2dEVzeVE/edit?usp=sharing") w PDF.
                        p Slajdy:
                            a(href="http://www.slideshare.net/michalwarecki/java-memory-model-23207253") pobieramy tutaj.
                        p Kod:
                            a(href="https://github.com/michalwarecki/java-memory-model") pobieramy tutaj.
                        p Zapisy i dyskusja:
                            a(href="http://www.meetup.com/Warszawa-Java-User-Group-Warszawa-JUG/events/123604012/", target='_blank')  Meetup
                        b O prezentacji:
                        p Java Memory Model (JMM) opisuje jak wątki współdziałają ze sobą poprzez pamięć. Czy wiesz, że instrukcje Twojego kodu mogą się wykonać w innej kolejności niż je napisałeś? Czy wiesz, że kilka wątków może widzieć zupełnie inną wartość tej samej zmiennej? Czy wiesz, że możesz mieć na to wpływ?
                        p Głównymi pojęciami wchodzącymi w skład JMM są: zmiana kolejności instrukcji, niepodzielność (atomowość) oraz widzialność. Aby pokazać jak to wszystko działa, sięgnę aż do instrukcji maszynowych generowanych przez HotSpot JVM.
                        b O prelegencie:
                        p Michał jest programistą skupiającym się na technologiach opartych o JVM. Jego głównymi obszarami zainteresowań są:
                        ul
                            li algorytmy GC,
                            li współbieżność,
                            li algorytmy wolne od blokad,
                            li kompilatory typu JIT.

                        p Tworząc oprogramowanie pamięta jak zbudowane są współczesne procesowy, pamięć fizyczne oraz system operacyjny. Nie ogranicza się tylko do poziomu bytecode'u lecz obserwuje także wewnętrzne komponenty OpenJDK oraz kod maszynowy przez nie generowany.
