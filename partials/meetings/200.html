
<div>
  <div page="1" class="section">
    <div class="centered">
      <div class="container">
        <div class="row">
          <div class="span12">
            <h4>200. spotkanie WJUG</h4>
            <h2>Spotkanie Jubileuszowe</h2>
            <p>Zapraszamy Was na wspólne świętowanie jubileuszowego spotkania numer 200. Specjalnie dla Was zaprosiliśmy kilku znanych prelegentów, którzy uświetnią ten dzień.</p>
            <h3>Kevlin Henney, Jan Pustelnik, Tomasz Nurkiewicz, Maciej Aniserowicz</h3>
            <p>Termin: 06.03.2017 godz. 17:45 (wyjątkowo poniedziałek)</p>
            <p>Lokalizacja: Aula Główna, Polsko-Japońska Akademia Technik Komputerowych (dawniej­ PJWSTK), ul. Koszykowa 86</p>
            <p>Sponsor:
              <p><a href="http://www.gft.com" target="_blank"><img src="/img/sponsors/gft.jpg" border="0" style="height: 100px"/></a></p>
            </p>
            <h3>Plan wydarzenia</h3>
            <p>17:45 Networking i poczęstunek</p>
            <p>18:00 Rozpoczęcie</p>
            <p>18:05 Metrics! But what do they mean? - Jan Pustelnik</p>
            <p>18:40 Asynchronous by default, synchronous when necessary - Tomasz Nurkiewicz</p>
            <p>19:30 Przerwa</p>
            <p>19:45 Getting More Done - Maciej Aniserowicz</p>
            <p>20:20 Seven Ineffective Coding Habits of Many Programmers - Kevlin Henney</p>
            <p>Zapisy na<a href="https://www.meetup.com/Warszawa-JUG/events/237830680/"> naszym meetupie.</a></p>
            <p><b>Uwaga:</b> Godziny startu poszczególnych prezentacji są orientacyjne.</p>
            <h2>Opisy prezentacji</h2>
            <h2>1. Metrics! But what do they mean?</h2>
            <p>Everyone loves metrics – we have them for everything: code coverage, defect density or code complexity. But what do they really mean? Can we just set the target at 100% (coverage) or 0 (defects, complexity) and start happily converging on it? Or maybe understanding those numbers needs understanding of what are they really standing in for? Can we have 100% test coverage and still have bugs? Can we succeed with 30% coverage? What about cyclomatic complexity? Let’s dive in!</p>
            <h3>Jan Pustelnik</h3>
            <p>Technical Architect at GFT Poland by day, sporadic Akka project contributor by night. Interested in how software works on low level, he does not find big frameworks appealing. This is why he loves Scala, an expressive language that allows one to build right abstractions quickly without losing control over details. Jan is an active member of JUG Łódź and occasional conference speaker. Currently he is busy with a Big Data project for one of major investment banks. In his spare time he loves to dust-off some old issue of computer science journal only to find out that everything has already been invented before he even was born.</p>
            <h2>2. Asynchronous by default, synchronous when necessary</h2>
            <p>In distributed systems, synchronous communication (RPC-style) is tempting but can quickly get out of hand. Suddenly you need to think about retrying, fallbacks, circuit breakers, failover, and latency. Tomasz Nurkiewicz explains how all of this can be avoided by preferring asynchronous communication between services, pub-sub patterns, and event sourcing. Too often migrations from monolith to microservices architecture are unsuccessful. Simply replacing in-process method calls with RESTful interfaces doesn’t mean we have a distributed system consisting of loosely coupled independent services. Quite the opposite: our architecture is now a tangled web of interconnected, slow, chatty, and unreliable components. Dozens of patterns were introduced to ease the pain, such as circuit breakers, scaling services horizontally, and load balancing — all of this to prevent cascading failures and increased latencies. We can achieve fast, loosely coupled, independent services only if we apply the dependency inversion principle at the architecture level. Moving to asynchronous communication via message passing and pub-sub patterns can prevent temporal coupling. Such coupling requires two systems to exist and work reliably at the same time in order to communicate. This is the biggest challenge in distributed systems that increases complexity, latency, and the possibility of failure.</p>
            <p>Tomasz demonstrates how pushing changes asynchronously between systems can improve fault tolerance and make systems more reliable, faster, and more independent, focusing on publishing (pushing) changes and rebuilding state on the client side as opposed to pulling data when needed. From this point jumping to event sourcing is quite natural. Along the way, Tomasz covers the drawbacks and challenges of this architectural style.</p>
            <h3>Tomasz Nurkiewicz</h3>
            <p>Senior software engineer at Allegro. Tomasz has spent half of his life programming (for the last decade professionally in Java land). He loves backend, tolerates JavaScript, is passionate about alternative JVM languages, is disappointed with the quality of software written these days (so often by himself!), and hates long methods and hidden side effects. Tomasz is interested in charting, data analysis and reporting and believes that computers were invented so that developers could automate boring and repetitive tasks. He is involved in open source and used to be very active on StackOverflow. Tomasz is an author, trainer, conference speaker, technical reviewer, and runner and has been recognized as DZone’s most valuable blogger. He claims that code not tested automatically is not a feature but just a rumour.</p>
            <h2>3. Getting More Done</h2>
            <p>"Co zrobić żeby zarobić a się nie narobić" - to dylemat cwaniaków od zarania dziejów. Zamiast tego powinniśmy się zastanawiać "jak zrobić jeszcze więcej?".</p>
            <p>Wszyscy jesteśmy zarobieni po pachy - normalna sprawa w "cywilizowanym" świecie. Jednak za pomocą pewnych technik, praktyk, zwyczajów i narzędzi można z życia wyciągnąć więcej niż do tej pory.</p>
            <p>Doba ma zbyt mało godzin? A może to po prostu my jesteśmy zbyt mało efektywni? Być może marnujemy więcej czasu, niż zdajemy sobie z tego sprawę?</p>
            <p>Jak ogarnąć wszystkie obowiązki, jednocześnie zostawiając parę chwil dla siebie? Jak wykorzystać każdą dostępną minutę? I nie zgubić nic po drodze.</p>
            <p>Podczas tego wystąpienia zaprezentuję swoje doświadczenia z ostatnich lat, kiedy to starałem się świadomie, metodycznie i starannie optymalizować codzienne zachowania i przyzwyczajenia tak, aby jak najmniej życia... "znikało".</p>
            <h3>Maciej Aniserowicz</h3>
            <p>Po pierwsze: programista-pasjonat. Człowiek od wszystkiego związanego z programowaniem. Po drugie: pragmatyczny trener z misją dostarczania wyjątkowych szkoleń, faktycznie zmieniających sposób pracy i myślenia. Współpracuje z firmą Bottega. Po trzecie: żyje i oddycha polską społecznością programistyczną. Autor jednego z najpopularniejszych dev-blogów: http://www.maciejaniserowicz.com. Twórca podcasta programistycznego: DevTalk. Prelegent na największych polskich konferencjach oraz grupach pasjonackich w całym kraju (lista wystąpień: tutaj, nagrania z prezentacji: tutaj). Jeden z liderów Białostockiej Grupy .NET oraz współorganizator konferencji Programistok. Od wielu lat jeden z trzech polskich Microsoft MVP (Most Valuable Professional) w kategorii .NET. Od 2005 posiadacz tytułu Microsoft Certified Professional.</p>
            <p>Prywatnie: mąż, tata. Słucha dobrej muzyki każdego rodzaju. Uwielbia jazdę samochodem i motocyklem. Na Twitterze: @maniserowicz.</p>
            <h2>4. Seven Ineffective Coding Habits of Many Programmers</h2>
            <p>Habits help you manage the complexity of code. You apply existing skill and knowledge automatically to the detail while focusing on the bigger picture. But because you acquire habits largely by imitation, and rarely question them, how do you know your habits are effective? Many of the habits and conventions programmers have for naming, formatting, commenting and unit testing do not stand up as rational and practical on closer inspection.</p>
            <p>This session examines seven coding habits that are not as effective as many programmers — whether working with Java, .NET, native or scripting languages — might believe, and suggests alternatives.</p>
            <h3>Kevlin Henney</h3>
            <p>An independent consultant and trainer based in the UK. His development interests are in patterns, programming, practice and process. He has been a columnist for various magazines and sites, including Better Software, The Register, Application Development Advisor, Java Report and the C/C++ Users Journal.</p>
            <p>Kevlin is co-author of A Pattern Language for Distributed Computing and On Patterns and Pattern Languages, two volumes in the Pattern-Oriented Software Architecture series. He is also editor of the 97 Things Every Programmer Should Know site and book.</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>